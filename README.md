# Custom RBAC Auth System (FastAPI)

Система управления пользователями и разграничения прав доступа на основе ролей (**RBAC**). Проект реализует гибкую логику авторизации, позволяющую управлять доступом к ресурсам на уровне конкретных действий и владения объектами.



## Установка и запуск

1. **Клонируйте репозиторий**:
   ```bash
   git clone https://github.com/PVkolos/Test-assignment-for-Effective-Mobile.git
   cd Test-assignment-for-Effective-Mobile
   ```
2. **Импортируйте дамб базы данных**
- Для вас постарался и заполнил базу данных необходимым минимальным набором данных 
(4 пользователя на все возможные роли, заполнил матрицу прав доступа для всех пользователей и всех блоков приложения (их тоже описал), несколько резюме, чтобы вы могли не заниматься этим). Создайте БД в postgres, импортируйте файл `dump_db.sql`

Если вы захотите отчистить базу и внести туда свои данные, в файле main.py раскомментируйте строку 12: `# await DataBase.create_table()`. Также, чтобы была возможность создать пользователя, в `src/api/users.py` закомментируйте строку 27: `creator: Annotated[...]` 
3. **Настройте .env**
* В файле `.env` заполните поля `DB_PASS` и `DB_NAME` соответственно тому, какие данные у вас
4. **Сертификаты jwt**. Замените сертификаты в папке certs на свои (названия файлов должны остаться прежними
5. **Установите зависимости и запустите приложение**
```bash
.venv\Scripts\activate.bat
cd src
pip install -r requirements.txt
python -m src.main
```
5. **Аутентификация, пользователи**
- user: `ivan@ignatov.com`, password: `password`, role: `user`
- user: `pavelkoloskov12@gmail.com`, password: `password`, role: `admin`
- user: `daniil@petrov.com`, password: `password`, role: `guest`
- user: `vladislav@serd.com`, password: `password`, role: `manager`

Вместо заглушек для демонстрации работоспособности системы разграничения прав доступа написал модель resumes - резюме пользователей, а также необходимые минимальные ручки для визуализации данных из БД.

## Основной функционал

* **Собственная система Auth**: Регистрация, вход (JWT с использованием RSA256), выход и "мягкое" удаление аккаунта (`is_active=False`).
* **Гибкая Матрица Прав**: Управление доступом к бизнес-объектам через централизованную таблицу правил `access_roles_rules`.
* **Разграничение "Своё/Чужое"**: Поддержка проверки прав на действия только со своими записями (`permission`) или со всеми записями в системе (`all_permission`).
* **Resumes**: Демонстрация работы системы прав на бизнес-объектах.

## Стек технологий

* **Framework**: FastAPI
* **Database**: PostgreSQL + SQLAlchemy 2.0 (Async)
* **Validation**: Pydantic v2 (с использованием `Annotated` и `model_validator`)
* **Security**: PyJWT (Асимметричное шифрование), Passlib (bcrypt для хеширования паролей)

## Структура проекта

```text
src/
├── api/                # Эндпоинты и логика зависимостей (permissions)
├── database/           # Настройка подключения и ORM-модели
│   └── models/         # Описание таблиц БД (User, Role, Resume и др.)
├── schemas/            # Pydantic модели (DTO) для валидации данных
├── certs/              # JWT ключи (private/public .pem)
└── config.py           # Конфигурация окружения и переменных
```

## Схема базы данных (RBAC)



### Описание моделей:
* **UserModel**: Данные профиля, хеш пароля и связь с ролью через `ForeignKey`.
* **RoleModel**: Справочник доступных ролей в системе.
* **BusinessElementModel**: Реестр объектов (ресурсов), доступ к которым подлежит контролю (например: `user`, `resume`).
* **AccessRoleRuleModel**: **Матрица прав.** Определяет уровни доступа (`Create`, `Read`, `Update`, `Delete`) для конкретной роли к конкретному элементу.
* **ResumeModel**: Пример сущности, имеющей владельца (`email`), на которой демонстрируется логика прав `own_permission` и `all_permission`.

---

## Логика авторизации

Доступ к защищенным маршрутам проверяется через кастомную зависимость `check_permissions(element_name, action)`:

1. **Authentication**: Извлечение и валидация JWT-токена. Проверка статуса `is_active`.
2. **Rule Lookup**: Поиск правила в `access_roles_rules` для роли текущего пользователя и запрашиваемого элемента.
3. **Permission Check**:
    * Если `action_all_permission == True` — доступ разрешен.
    * Если `action_permission == True` — проверяется, является ли пользователь владельцем объекта (сравнение по `email` или `id`).
    * В остальных случаях — возвращается ошибка `HTTP 403 Forbidden`

---
## Схема управления ограничениями прав доступа
Позаимствовал систему у вас, потому что не знал, что вообще такой подход актуален и хорош. Создал таблицы в БД (выше описаны). 
Пользователь дергает ручку, после чего, если для доступа к ней требуются специальные права, срабатывает зависимость, `Depends`, вызывается фабрика check_permissions (покрыл функцию комментариями, чтобы вы могли разобрать), 
куда передается имя "блока приложения" (user, resume) и действие, которое нужно совершить (create, read, update, delete). Проверяется право на редактирование чужих данных (`all`), затем - личных (из таблицы `access_roles_rules`). Очень кратко описал. Подробнее описывают функционал комментарии функции check_permissions.

## Резюме
Писал проект полтора дня. Много сил и стараний вложил, надеюсь, вы по достоинству их оцените). 
* **logout**. Написал весь функционал из ТЗ, кроме logout. Он всегда производится на стороне клиента (frontend). Можно, конечно, разлогиненные токены помещать в бд в blacklist, но я этого не сделал. Подумал, что не требуется.
* **ТЗ и FastAPI**. Написал удобную апишку, по адресу `http://127.0.0.1:8000/docs` и `http://127.0.0.1:8000/redoc` вы можете перейти к документации и оценить удобство использования ручек. Аутентификационные данные приложил сверху
* **Функциональный сахар**. Много приятностей и деталей. Валидация pydantic schema, грамотная работа с orm и многое другое